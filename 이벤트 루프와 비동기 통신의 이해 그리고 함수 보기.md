### 자바스크립트가 싱글 스레드인 이유를 분석하기
1. 자바스크립트가 나왔던 시기(1995년 경)에는 멀티 스레드에 대한 개념이 대중화되던 시기가 아니었다.
2. 자바스크립트는 단순히 버튼 위에 이미지 띄우기, 경고창 띄우기, 폼 처리같은 아주 기초적인 수준에서만 제한적으로 사용됐다. 즉, 설계 당시에는 현재와 같은 복잡한 처리를 JS가 할 것 이라고는 생각조차 안했다.
3. DOM을 여러 스레드에서 조작하면, 같은 자원에 대해 여러 번 수정하는 등 동시성 문제가 발생할 수 있어 브라우저의 DOM 표시에 큰 문제를 야기할 수 있다.

---

### 자바스크립트의 동기적인 특징으로 인해, 하나의 코드가 실행하는 데 오래 걸리면 뒤이은 코드가 실행되지 않는다는 것을 보고 "Run-to-completion"이라고 한다. 웹 페이지가 멈춘 것 같은 느낌을 줄 가능성이 높아 어려운 문제다.

---

### 자바스크립트에서 비동기 코드를 처리할 수 있게 하는 이벤트 루프 분석하기
1. 이벤트 루프는 ECMAScript 표준이 아니며, JS 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치다.
2. 호출 스택(call stack)은 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택이다.
3. 이벤트 루프는 호출 스택이 비어 있는지 여부를 확인하고, 자바스크립트 엔진을 이용하여 수행해야 할 코드를 실행한다. 이 두 작업은 동기적으로 일어난다.
4. 태스크 큐란, 실행해야 할 태스크의 집합을 의미하며 이벤트 루프는 이러한 태스크 큐를 한 개 이상 가지고 있다. 이름만 큐이고 set의 성질을 갖고 있다.
5. 모든 비동기 함수는 동기적으로 실행되는 메인 스레드가 아닌, 태스크 큐가 할당되는 별도의 스레드에서 실행된다. 즉, 자바스크립트 코드 실행만 메인 스레드이고 나머지는 자바스크립트 코드 외부이며 별도의 스레드의 태스크 큐에 들어간다.
6. 이벤트 루프는 호출 스택이 비고, 콜백이 실행 가능한 때가 오면 태스크 큐를 꺼내서 수행하는 역할을 하는 것이다.
7. 태스크 큐보다 한 차례 먼저 작동하는 마이크로 태스크 큐라는 것도 존재하는데, 이는 이벤트 루프가 하나씩 갖고 있다. 각 태스크에 들어가는 대표적인 작업은 다음과 같다.
```javascript
태스크 큐 : setTimeout, setInterval, setImmediate

마이크로 태스크 큐 : process.nextTick, Promises . . .
```
8. 렌더링은 마이크로 태스크 큐의 실행이 끝나고 일어난다.
9. 자바스크립트 코드(동기)나 마이크로 태스크 큐는 모든 작업이 끝나고 실행되지만, 태스크 큐는 하나씩 순차적으로 렌더링한다.

---

# 리액트에서 자주 사용하는 자바스크립트 문법

### 구조 분해 할당
1. 객체 구조 분해 할당은 사용하는 쪽에서 원하는 이름으로 변경하기 번거롭지만, 배열 구조 분해 할당은 위치에 구애받기 때문에 이름에서는 자유롭다. 둘 다 기본값 설정도 가능하다.(undefined일 때만 기본값을 사용한다.)
2. 객체 구조 분해 할당은 새로운 이름으로 재할당하는 것 또한 가능하다.
```javascript
const object = {
    a: 1,
    b: 2
};

const { a: first, b: second } = object;
// first 1
// second 2
```
3. 계산된 속성 이름 방식도 가능하다.
```javascript
function SampleComponent({a, b}) {
    return a + b;
}

SampleComponent({a: 3, b: 5}) // 8

// and

const key = 'a';
const object = {
    a: 1,
    b: 1
};

const { [key] : a } = object;

// a = 1
```
4. 객체 구조 분해 할당을 할 때도 비용이 꽤 세지만, 그 안에 ...rest와 같은 함수가 필요하다면 lodash나 rambda 라이브러리로 이를 대체하는 게 좋다. 객체 전개 연산자도 마찬가지다.

### Array.prototype.reduce 함수는 콜백 함수를 실행하고, 이를 초깃값에 누적해 결과를 반환한다.
```javascript
const arr = [1,2,3,4,5];
const sum = arr.reduce((result, item) => {
    return result + item;
}, 0);
// 15
```

### filter와 map을 혼합한 것을 reduce 하나로 작성할 수도 있지만, 코드가 직관적이지 않기에 reduce 사용을 자제하는 편이 좋다. 하지만 두 번 순환하는 게 코드가 직관적인 것보다 더 비효율적이라면 reduce를 사용하도록 하자.



